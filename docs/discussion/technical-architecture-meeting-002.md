# Defense Allies 기술 아키텍처 회의록 #002

## 📋 회의 정보
- **날짜**: 2024년 (기술 설계 단계)
- **참석자**: 개발자 (1인 개발)
- **회의 목적**: 서버 아키텍처 및 데이터 관리 방식 결정
- **회의 시간**: 약 1.5시간

## 🏗️ 주요 논의 사항

### 1. 서버 아키텍처 역할 재정의

#### 🔍 논의 배경
- 기존 서버 구조에서 각 서버의 역할 명확화 필요
- Guardian 서버의 책임 범위 재검토
- 게임 로직과 인증 로직의 분리 필요성

#### 📌 최종 결정사항

**GuardianApp (인증 전용)**
```
기존: 인증 + 종족 관리 + 플레이어 프로필
변경: 인증만 담당
```
- **AuthService**: 플레이어 인증 및 JWT 관리
- **SessionService**: 로그인 세션 관리
- **SecurityService**: 보안 및 권한 검증
- **데이터**: `auth:*` 스키마만 관리

**TimeSquareApp (게임 로직 전담)**
```
기존: 실시간 게임 로직
확장: 모든 게임 관련 로직
```
- **RaceService**: 종족 시스템 관리
- **EnvironmentService**: 환경 시스템 관리
- **DifficultyService**: 난이도 조절 시스템
- **CooperationService**: 협력 메커니즘 처리
- **PlayerProfileService**: 플레이어 게임 데이터 관리
- **데이터**: `race:*`, `environment:*`, `difficulty:*`, `game:*` 스키마

**CommandApp (관리/분석)**
```
기존: 운영 서버
확장: 관리자 도구 및 분석 시스템
```
- **AnalyticsService**: 게임 데이터 분석
- **BalancingService**: 실시간 밸런싱 도구
- **AdminService**: 관리자 도구 및 모니터링
- **데이터**: `admin:*` 스키마

#### 💡 변경 이유
- **단일 책임 원칙**: 각 서버가 명확한 하나의 책임만 담당
- **개발 효율성**: 팀별(1인이지만 역할별) 집중도 향상
- **유지보수성**: 서버별 독립적인 개발 및 배포 가능
- **확장성**: 각 서버를 독립적으로 스케일링 가능

### 2. 게임 정적 데이터 포맷 선택

#### 🔍 검토된 옵션들

**1. Protocol Buffers**
- ✅ 메모리 효율성 (JSON 대비 30-50% 절약)
- ✅ 파싱 속도 (3-5배 빠름)
- ✅ 타입 안전성
- ❌ 학습 곡선 높음
- ❌ 외부 에디팅 어려움

**2. FlatBuffers**
- ✅ 극도의 성능 (제로 카피)
- ✅ 메모리 효율성
- ❌ 복잡성 높음
- ❌ 디버깅 어려움
- ❌ 1인 개발에 과도함

**3. MessagePack**
- ✅ JSON 호환성
- ✅ 압축률 (50-80% 크기 감소)
- ✅ 간단한 사용법
- ❌ 외부 에디팅 제한

**4. YAML**
- ✅ 가독성 최고
- ✅ 주석 지원
- ✅ 외부 에디팅 용이
- ❌ 파싱 속도 느림
- ❌ 타입 안전성 부족

**5. JSON Schema + JSON**
- ✅ 즉시 시작 가능 (학습 비용 0)
- ✅ 외부 에디팅 용이
- ✅ 디버깅 쉬움
- ✅ 관계 표현 가능 (`$ref`)
- ✅ 검증 시스템 완비
- ❌ 메모리 효율성 상대적으로 낮음

#### 📌 최종 결정: JSON Schema + JSON

**결정 이유**:
1. **1인 개발 최적화**: 학습 비용 없이 즉시 시작 가능
2. **외부 에디팅**: VS Code, 웹 에디터에서 바로 편집
3. **관계 표현**: `$ref`로 데이터 간 관계 정의 가능
4. **검증 시스템**: JSON Schema로 실시간 검증
5. **디버깅 용이**: 브라우저에서 바로 확인 가능

**성능 고려사항**:
- 클라이언트 메모리 제약은 데이터 구조 최적화로 해결
- 필요시 추후 Protocol Buffers로 마이그레이션 가능

### 3. JSON Schema 관계 표현 능력 검증

#### 🔍 논의 내용
- JSON Schema로 ER 다이어그램 수준의 관계 표현 가능성
- 데이터 간 참조 무결성 검증 방법
- 관계 시각화 도구 활용 방안

#### 📌 확인된 사항

**관계 표현 방법**:
1. **`$ref` 참조**: 다른 스키마 정의 참조
2. **description 활용**: 관계 타입 명시 (FK, M:N 등)
3. **enum 제약**: 참조 가능한 값 제한
4. **배열 items**: 일대다, 다대다 관계 표현

**검증 시스템**:
- JSON Schema: 기본 타입 및 구조 검증
- 커스텀 스크립트: 관계 무결성 검증
- 실시간 검증: 개발 중 즉시 피드백

**시각화 도구**:
- **https://json-schema.app/**: 스키마 구조 시각화
- **Mermaid 자동 생성**: 관계도 다이어그램 생성
- **VS Code 확장**: 실시간 스키마 검증

#### 💡 관계 표현 예시
```json
{
  "tower": {
    "race_id": {
      "type": "string",
      "description": "FOREIGN KEY: References race.id"
    },
    "abilities": {
      "type": "array",
      "items": {
        "type": "string",
        "description": "MANY-TO-MANY: References ability.id"
      }
    },
    "synergies": {
      "type": "array",
      "items": {
        "properties": {
          "tower_id": {
            "type": "string",
            "description": "SELF-REFERENCE: References another tower.id"
          }
        }
      }
    }
  }
}
```

### 4. 개발 도구 및 워크플로우

#### 📌 확정된 도구 스택

**스키마 설계**:
- **https://json-schema.app/**: 스키마 시각화 및 설계
- **VS Code**: JSON Schema 확장으로 실시간 검증
- **jsonschema 라이브러리**: Python/Node.js 검증

**데이터 관리**:
- **VS Code**: 메인 에디팅 도구
- **Git**: 버전 관리 및 변경 추적
- **자동화 스크립트**: 관계 무결성 검증

**검증 워크플로우**:
```bash
1. 스키마 설계 (json-schema.app)
2. 데이터 작성 (VS Code)
3. 실시간 검증 (VS Code 확장)
4. 관계 검증 (커스텀 스크립트)
5. 게임 테스트
```

### 5. 데이터 구조 설계 원칙

#### 📌 확정된 원칙

**관계 표현**:
- `$ref`를 이용한 명시적 참조
- description으로 관계 타입 문서화
- 일관된 ID 명명 규칙 (race_id, tower_id 등)

**검증 전략**:
- JSON Schema: 기본 타입 및 구조
- 커스텀 로직: 비즈니스 규칙 및 관계 무결성
- 실시간 피드백: 개발 중 즉시 오류 발견

**확장성 고려**:
- 추후 데이터 추가를 위한 유연한 구조
- 하위 호환성 유지 방안
- 마이그레이션 전략 수립

**성능 최적화**:
- 클라이언트 메모리 제약 고려
- 지연 로딩 및 캐싱 전략
- 데이터 압축 및 최적화

## 🎯 주요 결정 사항 요약

### ✅ 확정된 기술 스택
1. **서버 아키텍처**: Guardian(인증), TimeSquare(게임), Command(관리)
2. **정적 데이터**: JSON Schema + JSON
3. **스키마 도구**: https://json-schema.app/
4. **검증 도구**: jsonschema 라이브러리
5. **에디팅 도구**: VS Code + JSON Schema 확장

### 🔧 기술적 이점
1. **개발 속도**: 즉시 시작 가능한 기술 스택
2. **유지보수**: 명확한 서버 역할 분담
3. **확장성**: 독립적인 서버 스케일링
4. **검증**: 실시간 데이터 무결성 확인
5. **협업**: 추후 팀 확장 시 명확한 구조

### 📋 다음 단계 액션
1. **JSON Schema 설계**: 타워 데이터 스키마 작성
2. **서버 구조 리팩토링**: Guardian 역할 축소
3. **검증 스크립트**: 관계 무결성 검증 도구 개발
4. **개발 환경**: VS Code 설정 및 확장 설치

## 💭 기술적 고려사항

### 성능 최적화 전략
- **메모리 효율**: 데이터 구조 최적화로 JSON 단점 보완
- **파싱 최적화**: 필요시 Protocol Buffers 마이그레이션 경로 확보
- **캐싱 전략**: 클라이언트 사이드 지능형 캐싱

### 확장성 고려
- **스키마 진화**: 하위 호환성 유지하는 스키마 변경
- **데이터 마이그레이션**: 자동화된 데이터 변환 도구
- **성능 모니터링**: 데이터 크기 및 로딩 시간 추적

### 위험 요소 및 대응
- **JSON 성능 한계**: 데이터 구조 최적화 및 압축 활용
- **관계 복잡성**: 단계적 복잡도 증가 및 검증 도구 활용
- **스키마 관리**: 버전 관리 및 문서화 체계 구축

---

**다음 회의 예정**: 컨텐츠 기획 단계에서 실제 데이터 스키마 설계
