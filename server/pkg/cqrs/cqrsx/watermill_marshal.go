package cqrsx

import (
	"cqrs"

	wcqrs "github.com/ThreeDotsLabs/watermill/components/cqrs"
	"github.com/ThreeDotsLabs/watermill/message"
)

// // CommandEventMarshaler marshals Commands and Events to Watermill's messages and vice versa.
// // Payload of the command needs to be marshaled to []bytes.
// type CommandEventMarshaler interface {
// 	// Marshal marshals Command or Event to Watermill's message.
// 	Marshal(v interface{}) (*message.Message, error)

// 	// Unmarshal unmarshals watermill's message to v Command or Event.
// 	Unmarshal(msg *message.Message, v interface{}) (err error)

// 	// Name returns the name of Command or Event.
// 	// Name is used to determine, that received command or event is event which we want to handle.
// 	Name(v interface{}) string

// 	// NameFromMessage returns the name of Command or Event from Watermill's message (generated by Marshal).
// 	//
// 	// When we have Command or Event marshaled to Watermill's message,
// 	// we should use NameFromMessage instead of Name to avoid unnecessary unmarshaling.
// 	NameFromMessage(msg *message.Message) string
// }

func NewWatermillJsonMarshaler(
	watermillMarshaler wcqrs.JSONMarshaler,
	eventRegistry EventRegistry,
) *WatermillJsonMarshaler {
	return &WatermillJsonMarshaler{
		watermill:      watermillMarshaler,
		eventMarshaler: JSONEventMarshaler{registry: eventRegistry},
	}
}

type WatermillJsonMarshaler struct {
	watermill      wcqrs.JSONMarshaler
	eventMarshaler JSONEventMarshaler
}

func (w WatermillJsonMarshaler) Marshal(v interface{}) (*message.Message, error) {
	if event, ok := v.(cqrs.EventMessage); ok {
		payload, err := MapEvent(event)
		if err != nil {
			return nil, err
		}

		return w.watermill.Marshal(payload)
	}

	return w.watermill.Marshal(v)
}

func (w WatermillJsonMarshaler) Unmarshal(msg *message.Message, v interface{}) error {

	// // eventType 필드 추출
	// meta := metadata{}
	// if err := json.Unmarshal(msg.Payload, &meta); err != nil {
	// 	return err
	// }
	// if meta.EventType == "" {
	// 	return w.watermill.Unmarshal(msg, v)
	// }

	// // 3. 완전한 데이터를 새로 생성된 구체적인 타입의 객체에 역직렬화
	// if err := json.Unmarshal(msg.Payload, v); err != nil {
	// 	return err
	// }

	// // 인터페이스 만족 확인 및 반환
	// eventMessage, ok := v.(cqrs.EventMessage)
	// if !ok {
	// 	return w.watermill.Unmarshal(msg, v)
	// }

	// cqrs.RehydrateEventMessage(eventMessage,
	// 	meta.EventID,
	// 	meta.EventType,
	// 	meta.AggregateID,
	// 	meta.AggregateType,
	// 	meta.Version,
	// 	meta.Metadata,
	// 	meta.Timestamp,
	// )

	// return nil
	return w.watermill.Unmarshal(msg, v)
}

func (w WatermillJsonMarshaler) Name(v interface{}) string {
	return w.watermill.Name(v)
}

func (w WatermillJsonMarshaler) NameFromMessage(msg *message.Message) string {
	return w.watermill.NameFromMessage(msg)
}
